%section.intro
  %section
    %h1 Real World (not) Rails
    %br
    %h3 Lessons Learned
    %h3 for Loving Your Codebase 2.5 Years Later
    %br
    %h2 Josh Cheek

  %section
    %h2 Introduction
    %ul
      %li 2.5 years on client project
      %li greenfield(ish)
      %li 5 brands now building in it
      %li some code is good, some is bad
      %li much of the bad has become good
      %li time gives perspective
      %li I read more than write
      %li new users need to be able to understand
      %li here is what I've learned
      %li many ideas are functional
      %li this talk works best as a conversation, so participate!

  %section
    %h2 Categories
    %ul
      %li Write maintainable code
      %li Minimize dependencies
      %li Be explicit
      %li Extras

%section.maintainable_code
  %section
    %h1 Maintainable Code

  %section
    %h2 Test your code
    %br
    %h3 we all know this

  %section
    %h2 You shouldn't be able to use an object incorrectly
    %pre.fragment
      %code.ruby
        :preserve
          User = Struct.new :first_name, :last_name do
            def full_name
              @full_name ||= "\#{first_name} \#{last_name}"
            end
          end

          user = User.new 'Paul', 'Pagel'
          user.full_name
          # => "Paul Pagel"

          user.first_name = 'Margaret'
          user.full_name
          # => "Paul Pagel"
    %h3.fragment In this case: mutable state breaks caching


  %section
    %h2 Don't hard-code assumptions
    %br
    %h3 Don't assume a current "always"
    %h3 Leave room for new use cases
    %pre.fragment
      %code.ruby
        :preserve
          class Loan < ActiveRecord::Base
            after_create :notify_user_they_got_the_loan
          end

          Loan.create!(user: .., apr:..., amount:...)

    %p.fragment
      Do I really
      %strong ALWAYS
      want to do this? Even if there are regulations, don't assume "yes".

  %section
    %h2 Build yourself tools
    %br
    %h3 Take the time to make your environment better
    %img{src: 'img/ttt1.png'}
    %img{src: 'img/ttt2.png'}


  %section
    %h2 Avoid modules (inheritance)
    %br
    %h3 Choose composition instead
    %pre.fragment
      %code.ruby
        :preserve
          class SomethingController < ApplicationController
            def create
              Rails.version                  # => "4.0.0"
              singleton_class.ancestors.size # => 63
              methods.size                   # => 336
            end
          end

  %section
    %h2 Don't invent requirements
    %br
    %p
      None of
      = link_to 'this', 'https://github.com/JoshCheek/surrogate/blob/e83ca978a72caa4f088903b5470ba37b05a87691/lib/surrogate/endower.rb#L58-76'
      nonsense is necessary

%section.minimize_dependencies
  %section
    %h1 Minimize Dependencies

  %section
    %h2 All dependencies point downwards
    %br
    %pre
      %code.ruby
        :preserve
          calculator = Calculator.new(self, @apr)
    %br
    %p
      If our class is immutable, this isn't such a big deal,
      we can think of it as dependency inversion.
      But we can't see how we change based on what this class does to us.

  %section
    %h2 Don't mutate inputs
    %br
    %h3 Especially to the outside world and to inputs.
    %h3 Work with values.
    %br
    %div
      %pre
        %code.ruby
          :preserve
            def accrue_interest(loan, start_date, end_date)
              loan.accrued_interest = (loan.daily_interest_rate * loan.principal) *
                                      (start_date - end_date)
            end

      %p becomes

      %pre
        %code.ruby
          :preserve
            def interest_accrued_over(loan, start_date, end_date)
              (loan.daily_interest_rate * loan.principal) *
              (start_date - end_date)
            end
            loan.accrued_interest = interest_accrued_over loan,
                                                          start_date,
                                                          end_date

  %section
    %h2 Tend towards primitives
    %pre
      %code.ruby
        :preserve
          def interest_accrued_over(loan, start_date, end_date)
            (loan.daily_interest_rate * loan.principal) *
            (start_date - end_date)
          end
          loan.accrued_interest = interest_accrued_over loan,
                                                        start_date,
                                                        end_date

    %p becomes

    %pre
      %code.ruby
        :preserve

          def interest_accrued_over(daily_interest_rate, principal,
                                      start_date, end_date)
            (daily_interest_rate * principal) *
            (start_date - end_date)
          end
          loan.accrued_interest = interest_accrued_over loan.daily_interest_rate,
                                                        loan.principal,
                                                        start_date,
                                                        end_date
    %pre
      %code.ruby
        :preserve
          interest_accrued_over D('1.23'), D('500'), start_date, end_date

  %section
    %h2 Remove Temporal Coupling
    %h3 Separate an object with a specific order of calls into a function and data structure

    %pre
      %code.ruby
        :preserve
          class Inputs < Struct.new(:payments, :sum)
            def initialize(loan)
              self.loan = loan
            end

            def calculate
              self.payments = @loan.payments.incoming.successful
              self.sum      = payments.map(&:amount).sum
            end
          end

    %p becomes

    %pre
      %code.ruby
        :preserve
          class Inputs < Struct.new(:payments, :sum)
            def self.for(loan)
              payments = loan.payments.incoming.successful
              sum      = payments.map(&:amount).sum
              new(payments, sum)
            end
          end


  %section
    %h2 Remove knowledge Coupling
    %br
    %h3 This takes many forms
    %br
    %pre
      %code.ruby
        :preserve
          def update_login(user, login)
            BackEnd::User.update user.id, login: login, email: login
          end
    %br
    %h3 Wait, why are we updating email?
    %h3 Push that down to the back end


%section.be_explicit
  %section
    %h1 Be Explicit

  %section
    %h2 Don't hide important details under abstractions
    %br
    %pre
      %code.ruby
        :preserve
          def padded_take ary, n
            pad(ary, n).take(n)
          end

    %br
    %ul
      %li.fragment What are we padding with?
      %li.fragment Are we padding the left or right side?
      %li.fragment Is the padding done eagerly or lazily?

    %br
    %br
    %pre.fragment
      %code.ruby
        :preserve
          def pad ary, n
            pad_length = [0, n - ary.length].max
            ary + [0] * pad_length
          end


  %section
    %h2 Function Objects
    %h3
      #{link_to 'Example 1', 'https://github.com/JoshCheek/seeing_is_believing/blob/master/lib/seeing_is_believing/binary/comment_formatter.rb'},
      #{link_to 'Example 2', 'https://github.com/JoshCheek/seeing_is_believing/blob/master/spec/binary/comment_formatter_spec.rb'}
    %br

    %pre
      %code.ruby
        :preserve
          class CreateLoanApplication
            def initialize(loan, ...)
              @loan = loan
            end

            def call # no inputs
              # ...
            end

            private

            # ...
          end

  %section
    %h2 More on Function Objects :D
    %br
    %h3 Advantages
    %br
    %ul
      %li An obvious place to start (when reading)
      %li No state (impossible to become a bad object)
      %li SRP
      %li Explicit arguments
      %li Answers `C.new.meth(arg)` or `C.new(arg).meth`


  %section
    %h2 Explicit Inputs
    %ul
      %li Pass in everything you need to do the job, don't rely on the external context
      %li Makes debugging much easier
      %li Reduces the amount of state that you need to keep in your head
      %li Makes refactoring easier
      %li Easier to test

  %section
    %h2 Examples of Explicit Inputs
    %br
    %pre
      %code.ruby
        :preserve
          def do_something(a, b)
            @c + ARGV.select { |arg| ... }
          end

    %p becomes

    %pre
      %code.ruby
        :preserve
          def do_something(argv, a, b, c)
            c + argv.select { |arg| ... }
          end

    %div.fragment
      %br
      %p another example

      %pre
        %code.ruby
          :preserve
            class SomethingController < ApplicationController
              def create
                # what can I even do in here?
              end
            end


  %section
    %h2 Kick everything off explicitly
    %pre
      %code.ruby
        :preserve
          class Loan
            after_create :notify_user_they_got_the_loan
          end

    %p becomes

    %pre
      %code.ruby
        :preserve
          class CreateLoan
            def call(...)
              loan = Loan.new(...)
              notify_user_they_got_the_loan if loan.save
            end
          end


  %section
    %h2 Caller is responsible for formatting inputs
    %br
    %pre
      %code.ruby
        :preserve
          def notify_user(user_or_id, message)
            user = user_or_id
            user = User.find user_or_id unless user.kind_of? User
            # ...
          end

    %br becomes
    %pre
      %code.ruby
        :preserve
          def notify_user(user, message)
            # ...
          end

  %section
    %h2 Avoid magic
    %pre
      %code.ruby
        :preserve
          FactoryGirl.define do
            factory :contract do
              contract_template
              decision 'approved'
              lender { Lender["netcredit"] }
            end

            factory :contract_template do
              # ...
            end
          end


  %section
    %h2 Avoid metaprogramming
    %br
    %ul
      %li Methods you can't see but can call
      %li Don't know who self is
      %li Can't guess how to use something
      %li Can't see consequences
      %li saving local variables because method invocations stop working

  %section
    %h2 Be wary of DSLs
    %br
    %ul
      %li Don't know who self is
      %li Can't see where things come from or go to
      %li Can't see what can modify what
      %li Often involve singletons
      %li Often affect state (e.g. Capybara DSL)

%section.extras
  %section
    %h2 Learn your tools
    %ul
      %li Your editor
      %li The console
      %li The language
      %li Your database
      %li Your Libraries
      %li Your browser

  %section
    %h2 Be honest

    %ul
      %li Admit your failures
      %li Estimate without ego or optimism
      %li You're not as good as you think you are
      %li Set accurate expectations
      %li Analyze what is working and not working
      %li Experiment with problem domains to find better ways
      %li Tell people when you disagree with them
      %li Accept criticism


%section.conclusion
  %section
    %h2 Categories
    %ul
      %li Write maintainable code
      %li Minimize dependencies
      %li Be explicit
      %li Extras
